<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Librequest: api/request.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Librequest
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0188a3e6da905bc60aceb35bf790b8c9.html">api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">request.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface de traitement des requetes et reponses HTTP.  
<a href="#details">More...</a></p>

<p><a href="request_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmessage.html">message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Objet message qui peut etre soit une requete, soit une reponse. utilisé pour communiquer entre le programme et la bibliothèque.  <a href="structmessage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ace6c609072c3b2eaca1e74b065d61dc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#ace6c609072c3b2eaca1e74b065d61dc4">MAXCLIENT</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ace6c609072c3b2eaca1e74b065d61dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84f3d458b916b971024022f2359ac338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmessage.html">message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#a84f3d458b916b971024022f2359ac338">getRequest</a> (short int port)</td></tr>
<tr class="memdesc:a84f3d458b916b971024022f2359ac338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de recuperation d'une requete, cette fonction est bloquante et doit etre appelée dans la boucle principale du programme. Cette fonction essaie de récupérer une requête entière pour la livrer à votre programme, mais si des cas d'erreur se produisent,elle livre ce qui a été recu à l'instant t sans filtrage, c'est votre programme qui devra traiter ces cas d'erreurs.  <a href="#a84f3d458b916b971024022f2359ac338">More...</a><br /></td></tr>
<tr class="separator:a84f3d458b916b971024022f2359ac338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b0b35a1a9e7762488df107f3af787a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#a78b0b35a1a9e7762488df107f3af787a">freeRequest</a> (<a class="el" href="structmessage.html">message</a> *r)</td></tr>
<tr class="memdesc:a78b0b35a1a9e7762488df107f3af787a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure de libération de la memoire quand le programme en a fini avec une requete (message *).  <a href="#a78b0b35a1a9e7762488df107f3af787a">More...</a><br /></td></tr>
<tr class="separator:a78b0b35a1a9e7762488df107f3af787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd23356e16868a36c3f8361edb240a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#acd23356e16868a36c3f8361edb240a24">sendReponse</a> (<a class="el" href="structmessage.html">message</a> *r)</td></tr>
<tr class="memdesc:acd23356e16868a36c3f8361edb240a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure d'envoi d'un message au client HTTP. Ici la réponse est totalement formée (entête et body) dans un buffer en mémoire avant d'être envoyée au client. cette fonction recopie les données dans un buffer et s'assure de les envoyer quand la socket est disponible (la procédure appelante put tout de suite libérer la mémoire)  <a href="#acd23356e16868a36c3f8361edb240a24">More...</a><br /></td></tr>
<tr class="separator:acd23356e16868a36c3f8361edb240a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85da2e74873990c15111d9c7b4dc6b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#ad85da2e74873990c15111d9c7b4dc6b3">writeDirectClient</a> (int i, char *buf, unsigned int len)</td></tr>
<tr class="memdesc:ad85da2e74873990c15111d9c7b4dc6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure (expérimentale) [alternative à sendReponse] d'envoi d'un buffer au client i. Il est parfois pratique d'écrire au client au fur et à mesure du traitement de la requête. La librairie ne peut pas determiner toute seule la fin de la réponse. Si vous utilisez cette fonction il faut OBLIGATOIREMENT utiliser la fonction endWriteDirectClient quand la réponse est finie. L'intérêt ici est de ne pas avoir à stocker dans des buffers la totalité de la réponse.  <a href="#ad85da2e74873990c15111d9c7b4dc6b3">More...</a><br /></td></tr>
<tr class="separator:ad85da2e74873990c15111d9c7b4dc6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60779dd9b78eab2685f71a69a504b9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#a60779dd9b78eab2685f71a69a504b9dc">endWriteDirectClient</a> (int i)</td></tr>
<tr class="memdesc:a60779dd9b78eab2685f71a69a504b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure (expérimentale) de déclaration de la fin de la réponse envoyée au client i HTTP. doit être utilisés si et seulement si vous utilisez writeDirectClient.  <a href="#a60779dd9b78eab2685f71a69a504b9dc">More...</a><br /></td></tr>
<tr class="separator:a60779dd9b78eab2685f71a69a504b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b1b52a1fe661d7ab6e33f6687e6d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="request_8h.html#af8b1b52a1fe661d7ab6e33f6687e6d4f">requestShutdownSocket</a> (int i)</td></tr>
<tr class="memdesc:af8b1b52a1fe661d7ab6e33f6687e6d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure de demande de cloture de la connexion, si la bibliothèque à encore des données à envoyer d'un sendReponse précédent, la connexion ne sera fermée qu'à la fin de cet envoi.  <a href="#af8b1b52a1fe661d7ab6e33f6687e6d4f">More...</a><br /></td></tr>
<tr class="separator:af8b1b52a1fe661d7ab6e33f6687e6d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface de traitement des requetes et reponses HTTP. </p>
<dl class="section author"><dt>Author</dt><dd>Quentin Giorgi </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>13 Decembre 2015</dd></dl>
<p>Fichier d'interface entre la bibliothèque et votre programme. Votre programme doit inclure ce fichier d'entete #include &lt;<a class="el" href="request_8h.html" title="Interface de traitement des requetes et reponses HTTP. ">request.h</a>&gt; La compilation doit inclure l'option -L. -lrequest</p>
<p>Exemple de programme: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span> </div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span> </div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span> </div>
<div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;arpa/inet.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="request_8h.html">request.h</a>&quot;</span>   </div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structmessage.html">message</a> *requete; </div>
<div class="line">    <a class="code" href="structmessage.html">message</a> *reponse;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> ( 1 ) {</div>
<div class="line">        <span class="comment">// on attend la reception d&#39;une requete </span></div>
<div class="line">        requete=<a class="code" href="request_8h.html#a84f3d458b916b971024022f2359ac338">getRequest</a>(8080);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Affichage de debug </span></div>
<div class="line">        printf(<span class="stringliteral">&quot;#########################################\nDemande recue depuis le client %d\n&quot;</span>,requete-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>); </div>
<div class="line">        printf(<span class="stringliteral">&quot;Client [%d] [%s:%d]\n&quot;</span>,requete-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>,inet_ntoa(requete-&gt;<a class="code" href="structmessage.html#a3c3a02f02d5ba650223498f95f30cb4c">clientAddress</a>-&gt;sin_addr),htons(requete-&gt;<a class="code" href="structmessage.html#a3c3a02f02d5ba650223498f95f30cb4c">clientAddress</a>-&gt;sin_port));</div>
<div class="line">        printf(<span class="stringliteral">&quot;Contenu de la demande %.*s\n\n&quot;</span>,requete-&gt;<a class="code" href="structmessage.html#a24bc7afeef646e268eefce5086872da8">len</a>,requete-&gt;<a class="code" href="structmessage.html#ae39c7ead60245755a62c4aefcb0ea53e">buf</a>);  </div>
<div class="line"></div>
<div class="line">        <span class="comment">// Si on a une reponse a faire</span></div>
<div class="line">        <span class="keywordflow">if</span> (argv[1]) {</div>
<div class="line">            <span class="keywordflow">if</span> (reponse=malloc(<span class="keyword">sizeof</span>(<a class="code" href="structmessage.html">message</a>))) { </div>
<div class="line">                reponse-&gt;<a class="code" href="structmessage.html#ae39c7ead60245755a62c4aefcb0ea53e">buf</a>=argv[1]; <span class="comment">// on devrait l&#39;allouer sinon</span></div>
<div class="line">                reponse-&gt;<a class="code" href="structmessage.html#a24bc7afeef646e268eefce5086872da8">len</a>=strlen(argv[1]); </div>
<div class="line">                reponse-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>=requete-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>; </div>
<div class="line">                <a class="code" href="request_8h.html#acd23356e16868a36c3f8361edb240a24">sendReponse</a>(reponse); </div>
<div class="line">                <span class="comment">// reponse est recopiée on peut tout de suite liberer la memoire</span></div>
<div class="line">                free(reponse); </div>
<div class="line">                <span class="comment">//optionnel, ici on clot la connexion tout de suite (HTTP/1.0) </span></div>
<div class="line">                <a class="code" href="request_8h.html#af8b1b52a1fe661d7ab6e33f6687e6d4f">requestShutdownSocket</a>(reponse-&gt;<a class="code" href="structmessage.html#a14bfec4a2137426f4b33df4c470310da">clientId</a>); </div>
<div class="line">            }</div>
<div class="line">        }       </div>
<div class="line">        <span class="comment">// on ne se sert plus de requete a partir de maintenant, on peut donc liberer... </span></div>
<div class="line">        <a class="code" href="request_8h.html#a78b0b35a1a9e7762488df107f3af787a">freeRequest</a>(requete); </div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> (1);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ace6c609072c3b2eaca1e74b065d61dc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAXCLIENT&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a60779dd9b78eab2685f71a69a504b9dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void endWriteDirectClient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure (expérimentale) de déclaration de la fin de la réponse envoyée au client i HTTP. doit être utilisés si et seulement si vous utilisez writeDirectClient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Le client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78b0b35a1a9e7762488df107f3af787a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmessage.html">message</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure de libération de la memoire quand le programme en a fini avec une requete (message *). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Le message à libérer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84f3d458b916b971024022f2359ac338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmessage.html">message</a> * getRequest </td>
          <td>(</td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de recuperation d'une requete, cette fonction est bloquante et doit etre appelée dans la boucle principale du programme. Cette fonction essaie de récupérer une requête entière pour la livrer à votre programme, mais si des cas d'erreur se produisent,elle livre ce qui a été recu à l'instant t sans filtrage, c'est votre programme qui devra traiter ces cas d'erreurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>port d'écoute de la socket, utilisé qu'au premier appel de la fonction, ensuite ce parametre est ignoré dans les appels successifs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>un pointeur vers une structure message. </dd></dl>

</div>
</div>
<a class="anchor" id="af8b1b52a1fe661d7ab6e33f6687e6d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void requestShutdownSocket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure de demande de cloture de la connexion, si la bibliothèque à encore des données à envoyer d'un sendReponse précédent, la connexion ne sera fermée qu'à la fin de cet envoi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>L'Id du client dont on doit fermer la connexion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd23356e16868a36c3f8361edb240a24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendReponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmessage.html">message</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure d'envoi d'un message au client HTTP. Ici la réponse est totalement formée (entête et body) dans un buffer en mémoire avant d'être envoyée au client. cette fonction recopie les données dans un buffer et s'assure de les envoyer quand la socket est disponible (la procédure appelante put tout de suite libérer la mémoire) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Le message à envoyer (recopié par la bibliothèque) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad85da2e74873990c15111d9c7b4dc6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void writeDirectClient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedure (expérimentale) [alternative à sendReponse] d'envoi d'un buffer au client i. Il est parfois pratique d'écrire au client au fur et à mesure du traitement de la requête. La librairie ne peut pas determiner toute seule la fin de la réponse. Si vous utilisez cette fonction il faut OBLIGATOIREMENT utiliser la fonction endWriteDirectClient quand la réponse est finie. L'intérêt ici est de ne pas avoir à stocker dans des buffers la totalité de la réponse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Le client </td></tr>
    <tr><td class="paramname">buf</td><td>Le message à envoyer (non recopié par la bibliothèque) </td></tr>
    <tr><td class="paramname">len</td><td>La longueur du message à envoyer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 3 2017 11:04:05 for Librequest by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
